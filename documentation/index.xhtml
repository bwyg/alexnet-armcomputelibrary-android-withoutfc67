<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="robots" content="NOINDEX, NOFOLLOW" /> <!-- Prevent indexing by search engines -->
<title>ARM Compute Library: Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ARM Compute Library
   &#160;<span id="projectnumber">17.05</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.xhtml"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.xhtml"><span>Namespaces</span></a></li>
      <li><a href="annotated.xhtml"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.xhtml"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.xhtml','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#S0_introduction">Introduction</a><ul><li class="level2"><a href="#S0_1_contact">Contact / Support</a></li>
</ul>
</li>
<li class="level1"><a href="#S1_file_organisation">File organisation</a></li>
<li class="level1"><a href="#S2_versions_changelog">Release versions and changelog</a><ul><li class="level2"><a href="#S2_1_versions">Release versions</a></li>
<li class="level2"><a href="#S2_2_changelog">Changelog</a></li>
</ul>
</li>
<li class="level1"><a href="#S3_how_to_build">How to build the library and the examples</a><ul><li class="level2"><a href="#S3_1_build_options">Build options</a></li>
<li class="level2"><a href="#S3_2_linux">Linux</a><ul><li class="level3"><a href="#S3_2_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_2_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_3_android">Android</a><ul><li class="level3"><a href="#S3_3_1_library">How to build the library ?</a></li>
<li class="level3"><a href="#S3_3_2_examples">How to manually build the examples ?</a></li>
</ul>
</li>
<li class="level2"><a href="#S3_4_cl_stub_library">The OpenCL stub library</a></li>
</ul>
</li>
<li class="level1"><a href="#S4_architecture">Library Architecture</a><ul><li class="level2"><a href="#S4_1">Core vs Runtime libraries</a></li>
<li class="level2"><a href="#S4_2_windows_kernels_mt_functions">Windows, kernels, multi-threading and functions</a><ul><li class="level3"><a href="#S4_2_1_windows">Windows</a></li>
<li class="level3"><a href="#S4_2_2">Kernels</a></li>
<li class="level3"><a href="#S4_2_3">Multi-threading</a></li>
<li class="level3"><a href="#S4_2_4">Functions</a></li>
<li class="level3"><a href="#S4_4_1_cl_scheduler">OpenCL Scheduler and kernel library</a></li>
<li class="level3"><a href="#S4_4_2_events_sync">OpenCL events and synchronisation</a></li>
<li class="level3"><a href="#S4_4_2_cl_neon">OpenCL / NEON interoperability</a></li>
</ul>
</li>
<li class="level2"><a href="#S4_5_algorithms">Algorithms</a></li>
<li class="level2"><a href="#S4_6_images_tensors">Images, padding, border modes and tensors</a><ul><li class="level3"><a href="#S4_6_1_padding_and_border">Padding and border modes</a><ul><li class="level4"><a href="#padding">Padding</a></li>
<li class="level4"><a href="#valid_region">Valid regions</a></li>
</ul>
</li>
<li class="level3"><a href="#S4_6_2_tensors">Tensors</a></li>
<li class="level3"><a href="#S4_6_3_description_conventions">Images and Tensors description conventions</a></li>
<li class="level3"><a href="#S4_6_4_working_with_objects">Working with Images and Tensors using iterators</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="S0_introduction"></a>
Introduction</h1>
<p>The ARM Computer Vision and Machine Learning library is a set of functions optimised for both ARM CPUs and GPUs using SIMD technologies.</p>
<p>Several builds of the library are available using various configurations:</p><ul>
<li>OS: Linux, Android or bare metal.</li>
<li>Architecture: armv7a (32bit) or arm64-v8a (64bit)</li>
<li>Technology: NEON / OpenCL / NEON and OpenCL</li>
<li>Debug / Asserts / Release: Use a build with asserts enabled to debug your application and enable extra validation. Once you are sure your application works as expected you can switch to a release build of the library for maximum performance.</li>
</ul>
<h2><a class="anchor" id="S0_1_contact"></a>
Contact / Support</h2>
<p>Please email <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a></p>
<p>In order to facilitate the work of the support team please provide the build information of the library you are using. To get the version of the library you are using simply run: </p><pre class="fragment">$ strings android-armv7a-cl-asserts/libarm_compute.so | grep arm_compute_version
arm_compute_version=v16.12 Build options: {'embed_kernels': '1', 'opencl': '1', 'arch': 'armv7a', 'neon': '0', 'asserts': '1', 'debug': '0', 'os': 'android', 'Werror': '1'} Git hash=f51a545d4ea12a9059fe4e598a092f1fd06dc858
</pre><h1><a class="anchor" id="S1_file_organisation"></a>
File organisation</h1>
<p>This archive contains:</p><ul>
<li>The <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> header and source files</li>
<li>The latest Khronos OpenCL 1.2 C headers from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a></li>
<li>The latest Khronos cl2.hpp from the <a href="https://www.khronos.org/registry/cl/">Khronos OpenCL registry</a> (API version 2.1 when this document was written)</li>
<li>The sources for a stub version of libOpenCL.so to help you build your application.</li>
<li>An examples folder containing a few examples to compile and link against the library.</li>
<li>A <a class="el" href="namespacetest__helpers.xhtml">test_helpers</a> folder containing headers with some boiler plate code used by the examples.</li>
<li>This documentation.</li>
</ul>
<p>You should have the following file organisation: </p><pre class="fragment">.
├── arm_compute --&gt; All the arm_compute headers
│   ├── core
│   │   ├── CL
│   │   │   ├── CLKernels.h --&gt; Includes all the OpenCL kernels at once
│   │   │   ├── CL specialisation of all the generic objects interfaces (ICLTensor, ICLImage, etc.)
│   │   │   ├── kernels --&gt; Folder containing all the OpenCL kernels
│   │   │   │   └── CL*Kernel.h
│   │   │   └── OpenCL.h --&gt; Wrapper to configure the Khronos OpenCL C++ header
│   │   ├── CPP
│   │   │   └── kernels --&gt; Folder containing all the CPP kernels
│   │   │   │   └── CPP*Kernel.h
│   │   ├── NEON
│   │   │   ├── kernels --&gt; Folder containing all the NEON kernels
│   │   │   │   └── NE*Kernel.h
│   │   │   └── NEKernels.h --&gt; Includes all the NEON kernels at once
│   │   ├── All common basic types (Types.h, Window, Coordinates, Iterator, etc.)
│   │   ├── All generic objects interfaces (ITensor, IImage, etc.)
│   │   └── Objects metadata classes (ImageInfo, TensorInfo, MultiImageInfo)
│   └── runtime
│       ├── CL
│       │   ├── CL objects &amp; allocators (CLArray, CLImage, CLTensor, etc.)
│       │   ├── functions --&gt; Folder containing all the OpenCL functions
│       │   │   └── CL*.h
│       │   └── CLFunctions.h --&gt; Includes all the OpenCL functions at once
│       ├── CPP
│       │   └── CPPScheduler.h --&gt; Basic pool of threads to execute CPP/NEON code on several cores in parallel
│       ├── NEON
│       │   ├── functions --&gt; Folder containing all the NEON functions
│       │   │   └── NE*.h
│       │   └── NEFunctions.h --&gt; Includes all the NEON functions at once
│       └── Basic implementations of the generic object interfaces (Array, Image, Tensor, etc.)
├── documentation
│   ├── index.xhtml
│   └── ...
├── documentation.xhtml -&gt; documentation/index.xhtml
├── examples
│   ├── cl_convolution.cpp
│   ├── neoncl_scale_median_gaussian.cpp
│   ├── neon_convolution.cpp
│   └── neon_scale.cpp
├── include
│   └── CL
│       └── Khronos OpenCL C headers and C++ wrapper
├── opencl-1.2-stubs
│   └── opencl_stubs.c
├── src
│   ├── core
│   │   └── ... (Same structure as headers)
│   │       └── CL
│   │           └── cl_kernels --&gt; All the OpenCL kernels
│   └── runtime
│       └── ... (Same structure as headers)
└── test_helpers --&gt; Boiler plate code used by examples
    └── Utils.h
</pre><h1><a class="anchor" id="S2_versions_changelog"></a>
Release versions and changelog</h1>
<h2><a class="anchor" id="S2_1_versions"></a>
Release versions</h2>
<p>All releases are numbered vYY.MM Where YY are the last two digits of the year, and MM the month number. If there is more than one release in a month then an extra sequential number is appended at the end: </p><pre class="fragment">v17.03 (First release of March 2017)
v17.03.1 (Second release of March 2017)
v17.04 (First release of April 2017)
</pre><dl class="section note"><dt>Note</dt><dd>We're aiming at releasing one major public release with new features per quarter. All releases in between will only contain bug fixes.</dd></dl>
<h2><a class="anchor" id="S2_2_changelog"></a>
Changelog</h2>
<p>v17.05 Public bug fixes release</p><ul>
<li>Various bug fixes</li>
<li>Remaining of the functions ported to use accurate padding.</li>
<li>Library does not link against OpenCL anymore (It uses dlopen / dlsym at runtime instead to determine whether or not OpenCL is available).</li>
<li>Added "free" method to allocator.</li>
<li>Minimum version of G++ required for armv7 Linux changed from 4.8 to 4.9</li>
</ul>
<p>v17.04 Public bug fixes release The following functions have been ported to use the new accurate padding:</p><ul>
<li><a class="el" href="classarm__compute_1_1_c_l_color_convert_kernel.xhtml">CLColorConvertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">CLEdgeNonMaxSuppressionKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">CLEdgeTraceKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">CLGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">CLGaussianPyramidVertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">CLGradientKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_channel_combine_kernel.xhtml">NEChannelCombineKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_fill_array_kernel.xhtml">NEFillArrayKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_hor_kernel.xhtml">NEGaussianPyramidHorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid_vert_kernel.xhtml">NEGaussianPyramidVertKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_score_f_p16_kernel.xhtml">NEHarrisScoreFP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_harris_score_kernel.xhtml">NEHarrisScoreKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">NEHOGDetectorKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">NELogits1DMaxKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_shift_exp_sum_kernel.xhtml">NELogits1DShiftExpSumKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_norm_kernel.xhtml">NELogits1DNormKernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_f_p16_kernel.xhtml">NENonMaximaSuppression3x3FP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_kernel.xhtml">NENonMaximaSuppression3x3Kernel</a></li>
</ul>
<p>v17.03.1 First Major public release of the sources</p><ul>
<li>Renamed the library to <a class="el" href="namespacearm__compute.xhtml">arm_compute</a></li>
<li>New CPP target introduced for C++ kernels shared between NEON and CL functions.</li>
<li>New padding calculation interface introduced and ported most kernels / functions to use it.</li>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">CLGEMMLowpMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_lowp.xhtml">CLGEMMLowp</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_normalization_layer_kernel.xhtml">NENormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_normalization_layer.xhtml">NENormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_transpose_kernel.xhtml">NETransposeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_transpose.xhtml">NETranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_logits1_d_max_kernel.xhtml">NELogits1DMaxKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_logits1_d_shift_exp_sum_kernel.xhtml">NELogits1DShiftExpSumKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_logits1_d_norm_kernel.xhtml">NELogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_softmax_layer.xhtml">NESoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_im2_col_kernel.xhtml">NEIm2ColKernel</a> <a class="el" href="classarm__compute_1_1_n_e_col2_im_kernel.xhtml">NECol2ImKernel</a> <a class="el" href="classarm__compute_1_1_n_e_convolution_layer_weights_reshape_kernel.xhtml">NEConvolutionLayerWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_convolution_layer.xhtml">NEConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">NEGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_fully_connected_layer.xhtml">NEFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp_matrix_multiply_kernel.xhtml">NEGEMMLowpMatrixMultiplyKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_lowp.xhtml">NEGEMMLowp</a></li>
</ul>
</li>
</ul>
<p>v17.03 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_gradient_kernel.xhtml">CLGradientKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_non_max_suppression_kernel.xhtml">CLEdgeNonMaxSuppressionKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_edge_trace_kernel.xhtml">CLEdgeTraceKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_canny_edge.xhtml">CLCannyEdge</a></li>
<li>GEMM refactoring + FP16 support: <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_interleave4x4_kernel.xhtml">CLGEMMInterleave4x4Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_transpose1x_w_kernel.xhtml">CLGEMMTranspose1xWKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_multiply_kernel.xhtml">CLGEMMMatrixMultiplyKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_addition_kernel.xhtml">CLGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_g_e_m_m.xhtml">CLGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_g_e_m_m_matrix_accumulate_biases_kernel.xhtml">CLGEMMMatrixAccumulateBiasesKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_fully_connected_layer.xhtml">CLFullyConnectedLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_transpose_kernel.xhtml">CLTransposeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_transpose.xhtml">CLTranspose</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_init_kernel.xhtml">CLLKTrackerInitKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage0_kernel.xhtml">CLLKTrackerStage0Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_stage1_kernel.xhtml">CLLKTrackerStage1Kernel</a>, <a class="el" href="classarm__compute_1_1_c_l_l_k_tracker_finalize_kernel.xhtml">CLLKTrackerFinalizeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_optical_flow.xhtml">CLOpticalFlow</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_normalization_layer_kernel.xhtml">CLNormalizationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_normalization_layer.xhtml">CLNormalizationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_laplacian_pyramid.xhtml">CLLaplacianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_laplacian_reconstruct.xhtml">CLLaplacianReconstruct</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_activation_layer_kernel.xhtml">NEActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_activation_layer.xhtml">NEActivationLayer</a></li>
<li>GEMM refactoring + FP16 support (Requires armv8.2 CPU): <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_interleave4x4_kernel.xhtml">NEGEMMInterleave4x4Kernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_transpose1x_w_kernel.xhtml">NEGEMMTranspose1xWKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_multiply_kernel.xhtml">NEGEMMMatrixMultiplyKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m_matrix_addition_kernel.xhtml">NEGEMMMatrixAdditionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_g_e_m_m.xhtml">NEGEMM</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_pooling_layer_kernel.xhtml">NEPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_pooling_layer.xhtml">NEPoolingLayer</a></li>
</ul>
</li>
</ul>
<p>v17.02.1 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_logits1_d_max_kernel.xhtml">CLLogits1DMaxKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_logits1_d_shift_exp_sum_kernel.xhtml">CLLogits1DShiftExpSumKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_logits1_d_norm_kernel.xhtml">CLLogits1DNormKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_softmax_layer.xhtml">CLSoftmaxLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_pooling_layer_kernel.xhtml">CLPoolingLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_pooling_layer.xhtml">CLPoolingLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_im2_col_kernel.xhtml">CLIm2ColKernel</a> <a class="el" href="classarm__compute_1_1_c_l_col2_im_kernel.xhtml">CLCol2ImKernel</a> <a class="el" href="classarm__compute_1_1_c_l_convolution_layer_weights_reshape_kernel.xhtml">CLConvolutionLayerWeightsReshapeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_convolution_layer.xhtml">CLConvolutionLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_remap_kernel.xhtml">CLRemapKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_remap.xhtml">CLRemap</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_hor_kernel.xhtml">CLGaussianPyramidHorKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_vert_kernel.xhtml">CLGaussianPyramidVertKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid.xhtml">CLGaussianPyramid</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_half.xhtml">CLGaussianPyramidHalf</a>, <a class="el" href="classarm__compute_1_1_c_l_gaussian_pyramid_orb.xhtml">CLGaussianPyramidOrb</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_min_max_kernel.xhtml">CLMinMaxKernel</a>, <a class="el" href="classarm__compute_1_1_c_l_min_max_location_kernel.xhtml">CLMinMaxLocationKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_min_max_location.xhtml">CLMinMaxLocation</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_non_linear_filter_kernel.xhtml">CLNonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_non_linear_filter.xhtml">CLNonLinearFilter</a></li>
</ul>
</li>
<li>New NEON FP16 kernels (Requires armv8.2 CPU)<ul>
<li><a class="el" href="classarm__compute_1_1_n_e_accumulate_weighted_f_p16_kernel.xhtml">NEAccumulateWeightedFP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_box3x3_f_p16_kernel.xhtml">NEBox3x3FP16Kernel</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_maxima_suppression3x3_f_p16_kernel.xhtml">NENonMaximaSuppression3x3FP16Kernel</a></li>
</ul>
</li>
</ul>
<p>v17.02 Sources preview</p><ul>
<li>New OpenCL kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_c_l_activation_layer_kernel.xhtml">CLActivationLayerKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_activation_layer.xhtml">CLActivationLayer</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_channel_combine_kernel.xhtml">CLChannelCombineKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_combine.xhtml">CLChannelCombine</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_derivative_kernel.xhtml">CLDerivativeKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_channel_extract.xhtml">CLChannelExtract</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_fast_corners_kernel.xhtml">CLFastCornersKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_fast_corners.xhtml">CLFastCorners</a></li>
<li><a class="el" href="classarm__compute_1_1_c_l_mean_std_dev_kernel.xhtml">CLMeanStdDevKernel</a> / <a class="el" href="classarm__compute_1_1_c_l_mean_std_dev.xhtml">CLMeanStdDev</a></li>
</ul>
</li>
<li>New NEON kernels / functions:<ul>
<li><a class="el" href="classarm__compute_1_1_h_o_g.xhtml" title="CPU implementation of HOG data-object. ">HOG</a> / SVM: <a class="el" href="classarm__compute_1_1_n_e_h_o_g_orientation_binning_kernel.xhtml">NEHOGOrientationBinningKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_block_normalization_kernel.xhtml">NEHOGBlockNormalizationKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector_kernel.xhtml">NEHOGDetectorKernel</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_non_maxima_suppression_kernel.xhtml">NEHOGNonMaximaSuppressionKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_h_o_g_descriptor.xhtml">NEHOGDescriptor</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_detector.xhtml">NEHOGDetector</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_gradient.xhtml">NEHOGGradient</a>, <a class="el" href="classarm__compute_1_1_n_e_h_o_g_multi_detection.xhtml">NEHOGMultiDetection</a></li>
<li><a class="el" href="classarm__compute_1_1_n_e_non_linear_filter_kernel.xhtml">NENonLinearFilterKernel</a> / <a class="el" href="classarm__compute_1_1_n_e_non_linear_filter.xhtml">NENonLinearFilter</a></li>
</ul>
</li>
<li>Introduced a <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a> to manage the default context and command queue used by the runtime library and create synchronisation events.</li>
<li>Switched all the kernels / functions to use tensors instead of images.</li>
<li>Updated documentation to include instructions to build the library from sources.</li>
</ul>
<p>v16.12 Binary preview release</p><ul>
<li>Original release</li>
</ul>
<h1><a class="anchor" id="S3_how_to_build"></a>
How to build the library and the examples</h1>
<h2><a class="anchor" id="S3_1_build_options"></a>
Build options</h2>
<p>scons 2.3 or above is required to build the library. To see the build options available simply run <code>scons -h</code>: </p><pre class="fragment">debug: Debug (default=0) (0|1)
    default: 0
    actual: 0

asserts: Enable asserts (This flag is forced to 1 for debug=1) (default=0) (0|1)
    default: 0
    actual: 0

arch: Target Architecture (default=armv7a) (armv7a|arm64-v8a|arm64-v8.2-a|x86_32|x86_64)
    default: armv7a
    actual: armv7a

os: Target OS (default=linux) (linux|android|bare_metal)
    default: linux
    actual: linux

build: Build type: (default=cross_compile) (native|cross_compile)
    default: cross_compile
    actual: cross_compile

Werror: Enable/disable the -Werror compilation flag (Default=1) (0|1)
    default: 1
    actual: 1

opencl: Enable OpenCL support(Default=1) (0|1)
    default: 1
    actual: 1

neon: Enable Neon support(Default=0) (0|1)
    default: 0
    actual: 0

embed_kernels: Embed OpenCL kernels in library binary(Default=0) (0|1)
    default: 0
    actual: 0

set_soname: Set the library's soname and shlibversion (Requires SCons 2.4 or above) (yes|no)
    default: 0
    actual: False

extra_cxx_flags: Extra CXX flags to be appended to the build command
    default:
    actual:
</pre><p>Debug / asserts:</p><ul>
<li>With debug=1 asserts are enabled, and the library is built with symbols and no optimisations enabled.</li>
<li>With debug=0 and asserts=1: Optimisations are enabled and symbols are removed, however all the asserts are still present (This is about 20% slower than the release build)</li>
<li>With debug=0 and asserts=0: All optimisations are enable and no validation is performed, if the application misuses the library it is likely to result in a crash. (Only use this mode once you are sure your application is working as expected).</li>
</ul>
<p>Architecture: The x86_32 and x86_64 targets can only be used with neon=0 and opencl=1.</p>
<p>OS: Choose the operating system you are targeting: Linux, Android or bare metal. </p><dl class="section note"><dt>Note</dt><dd>bare metal can only be used for NEON (not OpenCL), only static libraries get built and NEON's multi-threading support is disabled.</dd></dl>
<p>Build type: you can either build directly on your device (native) or cross compile from your desktop machine (cross-compile). In both cases make sure the compiler is available in your path.</p>
<p>Werror: If you are compiling using the same toolchains as the ones used in this guide then there shouldn't be any warning and therefore you should be able to keep Werror=1. If with a different compiler version the library fails to build because of warnings interpreted as errors then, if you are sure the warnings are not important, you might want to try to build with Werror=0 (But please do report the issue either on Github or by an email to <a href="#" onclick="location.href='mai'+'lto:'+'dev'+'el'+'ope'+'r@'+'arm'+'.c'+'om'; return false;">devel<span style="display: none;">.nosp@m.</span>oper<span style="display: none;">.nosp@m.</span>@arm.<span style="display: none;">.nosp@m.</span>com</a> so that the issue can be addressed).</p>
<p>OpenCL / NEON: Choose which SIMD technology you want to target. (NEON for ARM Cortex-A CPUs or OpenCL for ARM Mali GPUs)</p>
<p>embed_kernels: For OpenCL only: set embed_kernels=1 if you want the OpenCL kernels to be built in the library's binaries instead of being read from separate ".cl" files. If embed_kernels is set to 0 then the application can set the path to the folder containing the OpenCL kernel files by calling <a class="el" href="classarm__compute_1_1_c_l_kernel_library.xhtml#af353532ea782387df6bcb6d01894f4ae" title="Initialises the kernel library. ">CLKernelLibrary::init()</a>. By default the path is set to "./cl_kernels".</p>
<p>set_soname: Do you want to build the versioned version of the library ? If enabled the library will contain a SONAME and SHLIBVERSION and some symlinks will automatically be created between the objects. Example: libarm_compute_core.so -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1 -&gt; libarm_compute_core.so.1.0.0 libarm_compute_core.so.1.0.0</p>
<dl class="section note"><dt>Note</dt><dd>This options is disabled by default as it requires SCons version 2.4 or above.</dd></dl>
<p>extra_cxx_flags: Custom CXX flags which will be appended to the end of the build command.</p>
<h2><a class="anchor" id="S3_2_linux"></a>
Linux</h2>
<h3><a class="anchor" id="S3_2_1_library"></a>
How to build the library ?</h3>
<p>For Linux, the library was successfully built and tested using the following Linaro GCC toolchain:</p>
<ul>
<li>gcc-linaro-arm-linux-gnueabihf-4.9-2014.07_linux</li>
<li>gcc-linaro-4.9-2016.02-x86_64_aarch64-linux-gnu</li>
<li>gcc-linaro-6.3.1-2017.02-i686_aarch64-linux-gnu</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you are building with opencl=1 then scons will expect to find libOpenCL.so either in the current directory or in "build" (See the section below if you need a stub OpenCL library to link against)</dd></dl>
<p>To cross-compile the library in debug mode, with NEON only support, for Linux 32bit: </p><pre class="fragment">scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=linux arch=armv7a
</pre><p>To cross-compile the library in asserts mode, with OpenCL only support, for Linux 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=linux arch=arm64-v8a
</pre><p>You can also compile the library natively on an ARM device by using <b>build=native</b>: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=arm64-v8a build=native
scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=native
</pre><dl class="section note"><dt>Note</dt><dd>G++ for ARM is mono-arch, therefore if you want to compile for Linux 32bit on a Linux 64bit platform you will have to use a cross compiler.</dd></dl>
<p>For example on a 64bit Debian based system you would have to install <b>g++-arm-linux-gnueabihf</b> </p><pre class="fragment">apt-get install g++-arm-linux-gnueabihf
</pre><p>Then run </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a build=cross_compile
</pre><p>or simply remove the build parameter as build=cross_compile is the default value: </p><pre class="fragment">scons Werror=1 -j8 debug=0 neon=1 opencl=0 os=linux arch=armv7a
</pre><dl class="section attention"><dt>Attention</dt><dd>To cross compile with opencl=1 you need to make sure to have a version of libOpenCL matching your target architecture.</dd></dl>
<h3><a class="anchor" id="S3_2_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> and libOpenCL binaries are present in the current directory or in the system library path. If this is not the case you can specify the location of the pre-built library with the compiler option -L. When building the OpenCL example the commands below assume that the CL headers are located in the include folder where the command is executed.</dd></dl>
<p>To cross compile a NEON example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/neon_convolution.cpp test_helpers/Utils.cpp -I. -std=c++11 -mfpu=neon -L. -larm_compute -o neon_convolution
</pre><p>To cross compile a NEON example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/neon_convolution.cpp test_helpers/Utils.cpp -I. -std=c++11 -L. -larm_compute -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To cross compile an OpenCL example for Linux 32bit: </p><pre class="fragment">arm-linux-gnueabihf-g++ examples/cl_convolution.cpp test_helpers/Utils.cpp -I. -Iinclude -std=c++11 -mfpu=neon -L. -larm_compute -lOpenCL -o cl_convolution
</pre><p>To cross compile an OpenCL example for Linux 64bit: </p><pre class="fragment">aarch64-linux-gnu-g++ examples/cl_convolution.cpp test_helpers/Utils.cpp -I. -Iinclude -std=c++11 -L. -larm_compute -lOpenCL -o cl_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option and the compiler's name is different)</p>
<p>To compile natively (i.e directly on an ARM device) for NEON for Linux 32bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp test_helpers/Utils.cpp -I. -std=c++11 -mfpu=neon -larm_compute -o neon_convolution
</pre><p>To compile natively (i.e directly on an ARM device) for NEON for Linux 64bit: </p><pre class="fragment">g++ examples/neon_convolution.cpp test_helpers/Utils.cpp -I. -std=c++11 -larm_compute -o neon_convolution
</pre><p>(notice the only difference with the 32 bit command is that we don't need the -mfpu option)</p>
<p>To compile natively (i.e directly on an ARM device) for OpenCL for Linux 32bit or Linux 64bit: </p><pre class="fragment">g++ examples/cl_convolution.cpp test_helpers/Utils.cpp -I. -Iinclude -std=c++11 -larm_compute -lOpenCL -o cl_convolution
</pre><dl class="section note"><dt>Note</dt><dd>These two commands assume libarm_compute.so is available in your library path, if not add the path to it using -L</dd></dl>
<p>To run the built executable simply run: </p><pre class="fragment">LD_LIBRARY_PATH=build ./neon_convolution
</pre><p>or </p><pre class="fragment">LD_LIBRARY_PATH=build ./cl_convolution
</pre><dl class="section note"><dt>Note</dt><dd>If you built the library with support for both OpenCL and NEON you will need to link against OpenCL even if your application only uses NEON.</dd></dl>
<h2><a class="anchor" id="S3_3_android"></a>
Android</h2>
<p>For Android, the library was successfully built and tested using Google's standalone toolchains:</p><ul>
<li>arm-linux-androideabi-4.9 for armv7a (clang++)</li>
<li>aarch64-linux-android-4.9 for arm64-v8a (g++)</li>
</ul>
<p>Here is a guide to <a href="https://developer.android.com/ndk/guides/standalone_toolchain.html">create your Android standalone toolchains from the NDK</a></p>
<ul>
<li>Download the NDK r14 beta 2 from here: <a href="https://developer.android.com/ndk/downloads/index.html">https://developer.android.com/ndk/downloads/index.html</a></li>
<li>Make sure you have Python 2 installed on your machine.</li>
<li>Generate the 32 and/or 64 toolchains by running the following commands:</li>
</ul>
<pre class="fragment">$NDK/build/tools/make_standalone_toolchain.py --arch arm64 --install-dir $MY_TOOLCHAINS/aarch64-linux-android-4.9 --stl gnustl
$NDK/build/tools/make_standalone_toolchain.py --arch arm --install-dir $MY_TOOLCHAINS/arm-linux-androideabi-4.9 --stl gnustl
</pre><dl class="section attention"><dt>Attention</dt><dd>Due to some NDK issues make sure you use g++ &amp; gnustl for aarch64 and clang++ &amp; gnustl for armv7</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Make sure to add the toolchains to your PATH: export PATH=$PATH:$MY_TOOLCHAINS/aarch64-linux-android-4.9/bin:$MY_TOOLCHAINS/arm-linux-androideabi-4.9/bin</dd></dl>
<h3><a class="anchor" id="S3_3_1_library"></a>
How to build the library ?</h3>
<dl class="section note"><dt>Note</dt><dd>If you are building with opencl=1 then scons will expect to find libOpenCL.so either in the current directory or in "build" (See the section below if you need a stub OpenCL library to link against)</dd></dl>
<p>To cross-compile the library in debug mode, with NEON only support, for Android 32bit: </p><pre class="fragment">CXX=clang++ CC=clang scons Werror=1 -j8 debug=1 neon=1 opencl=0 os=android arch=armv7a
</pre><dl class="section attention"><dt>Attention</dt><dd>Due to some NDK issues make sure you use g++ &amp; gnustl for aarch64 and clang++ &amp; libc++ for armv7</dd></dl>
<p>To cross-compile the library in asserts mode, with OpenCL only support, for Android 64bit: </p><pre class="fragment">scons Werror=1 -j8 debug=0 asserts=1 neon=0 opencl=1 embed_kernels=1 os=android arch=arm64-v8a
</pre><h3><a class="anchor" id="S3_3_2_examples"></a>
How to manually build the examples ?</h3>
<p>The examples get automatically built by scons as part of the build process of the library described above. This section just describes how you can build and link your own application against our library.</p>
<dl class="section note"><dt>Note</dt><dd>The following command lines assume the <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> binaries are present in the current directory or in the system library path.</dd></dl>
<p>Once you've got your Android standalone toolchain built and added to your path you can do the following:</p>
<p>To cross compile a NEON example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/neon_convolution.cpp -I. -Iinclude -std=c++11 -larm_compute-static -L. -o neon_convolution_arm -static-libstdc++ -pie
#64 bit:
aarch64-linux-android-g++ examples/neon_convolution.cpp -I. -Iinclude -std=c++11 -larm_compute-static -L. -o neon_convolution_aarch64 -static-libstdc++ -pie
</pre><p>To cross compile an OpenCL example: </p><pre class="fragment">#32 bit:
arm-linux-androideabi-clang++ examples/cl_convolution.cpp -I. -Iinclude -std=c++11 -larm_compute-static -L. -o cl_convolution_arm -static-libstdc++ -pie -lOpenCL
#64 bit:
aarch64-linux-android-g++ examples/cl_convolution.cpp -I. -Iinclude -std=c++11 -larm_compute-static -L. -o cl_convolution_aarch64 -static-libstdc++ -pie -lOpenCL
</pre><dl class="section note"><dt>Note</dt><dd>Due to some issues in older versions of the Mali OpenCL DDK (&lt;= r13p0), we recommend to link <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> statically on Android.</dd></dl>
<p>Then you need to do is upload the executable and the shared library to the device using ADB: </p><pre class="fragment">adb push neon_convolution_arm /data/local/tmp/
adb push cl_convolution_arm /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_arm
adb shell /data/local/tmp/cl_convolution_arm
</pre><p>For 64bit: </p><pre class="fragment">adb push neon_convolution_aarch64 /data/local/tmp/
adb push cl_convolution_aarch64 /data/local/tmp/
adb shell chmod 777 -R /data/local/tmp/
</pre><p>And finally to run the example: </p><pre class="fragment">adb shell /data/local/tmp/neon_convolution_aarch64
adb shell /data/local/tmp/cl_convolution_aarch64
</pre><h2><a class="anchor" id="S3_4_cl_stub_library"></a>
The OpenCL stub library</h2>
<p>In the opencl-1.2-stubs folder you will find the sources to build a stub OpenCL library which then can be used to link your application or <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> against.</p>
<p>If you preferred you could retrieve the OpenCL library from your device and link against this one but often this library will have dependencies on a range of system libraries forcing you to link your application against those too even though it is not using them.</p>
<dl class="section warning"><dt>Warning</dt><dd>This OpenCL library provided is a stub and <em>not</em> a real implementation. You can use it to resolve OpenCL's symbols in <a class="el" href="namespacearm__compute.xhtml">arm_compute</a> while building the example but you must make sure the real libOpenCL.so is in your PATH when running the example or it will not work.</dd></dl>
<p>To cross-compile the stub OpenCL library simply run: </p><pre class="fragment">&lt;target-prefix&gt;-gcc -o libOpenCL.so -Iinclude opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
</pre><p>For example: </p><pre class="fragment">&lt;target-prefix&gt;-gcc -o libOpenCL.so -Iinclude opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
#Linux 32bit
arm-linux-gnueabihf-gcc -o libOpenCL.so -Iinclude opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
#Linux 64bit
aarch64-linux-gnu-gcc -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC
#Android 32bit
arm-linux-androideabi-clang -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
#Android 64bit
aarch64-linux-android-gcc -o libOpenCL.so -Iinclude -shared opencl-1.2-stubs/opencl_stubs.c -fPIC -shared
</pre><h1><a class="anchor" id="S4_architecture"></a>
Library Architecture</h1>
<h2><a class="anchor" id="S4_1"></a>
Core vs Runtime libraries</h2>
<p>The Core library is a low level collection of algorithms implementations, it is designed to be embedded in existing projects and applications:</p>
<ul>
<li>It doesn't allocate any memory (All the memory allocations/mappings have to be handled by the caller).</li>
<li>It doesn't perform any kind of multi-threading (but provide information to the caller about how the workload can be split).</li>
</ul>
<p>The Runtime library is a very basic wrapper around the Core library which can be used for quick prototyping, it is basic in the sense that:</p>
<ul>
<li>It allocates images and tensors are allocatd using standard malloc().</li>
<li>It multi-threads NEON code in a very basic way using a very simple pool of threads.</li>
<li>For OpenCL it will use the default <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a> command queue for all mapping operations and kernels.</li>
</ul>
<p>For maximum performance, it is expected that the users would re-implement an equivalent to the runtime library which suits better their needs (With a more clever multi-threading strategy, load-balancing between NEON and OpenCL, etc.)</p>
<h2><a class="anchor" id="S4_2_windows_kernels_mt_functions"></a>
Windows, kernels, multi-threading and functions</h2>
<h3><a class="anchor" id="S4_2_1_windows"></a>
Windows</h3>
<p>A <a class="el" href="classarm__compute_1_1_window.xhtml">Window</a> represents a workload to execute, it's made of up to <a class="el" href="classarm__compute_1_1_dimensions.xhtml#a1b67d5b720119d50faa286c774579ecc">Coordinates::num_max_dimensions</a> dimensions. Each dimension is defined by a start, end and step.</p>
<p>It can split into subwindows as long as <em>all</em> the following rules remain true for all the dimensions:</p>
<ul>
<li>max[n].start() &lt;= sub[n].start() &lt; max[n].end()</li>
<li>sub[n].start() &lt; sub[n].end() &lt;= max[n].end()</li>
<li>max[n].step() == sub[n].step()</li>
<li>(sub[n].start() - max[n].start()) % max[n].step() == 0</li>
<li>(sub[n].end() - sub[n].start()) % max[n].step() == 0</li>
</ul>
<h3><a class="anchor" id="S4_2_2"></a>
Kernels</h3>
<p>Each implementation of the <a class="el" href="classarm__compute_1_1_i_kernel.xhtml">IKernel</a> interface (base class of all the kernels in the core library) works in the same way:</p>
<p>OpenCL kernels:</p>
<div class="fragment"><div class="line"><span class="comment">// Initialise the CLScheduler with the default context and default command queue</span></div><div class="line"><span class="comment">// Also initialises the CLKernelLibrary to use ./cl_kernels as location for OpenCL kernels files and sets a default device for which OpenCL programs are built.</span></div><div class="line"><a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a19bb5002a62b62e050e89c975f7b9fdf">default_init</a>();</div><div class="line"></div><div class="line">cl::CommandQueue q = <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#ad381d1aed28b4b1e1f5a710633934580">queue</a>();</div><div class="line"><span class="comment">//Create a kernel object:</span></div><div class="line">MyKernel kernel;</div><div class="line"><span class="comment">// Initialize the kernel with the input/output and options you want to use:</span></div><div class="line">kernel.configure( input, output, option0, option1);</div><div class="line"><span class="comment">// Retrieve the execution window of the kernel:</span></div><div class="line"><span class="keyword">const</span> Window&amp; max_window = kernel.window();</div><div class="line"><span class="comment">// Run the whole kernel in the current thread:</span></div><div class="line">kernel.run( q, max_window ); <span class="comment">// Enqueue the kernel to process the full window on the default queue</span></div><div class="line"></div><div class="line"><span class="comment">// Wait for the processing to complete:</span></div><div class="line">q.finish();</div></div><!-- fragment --><p>NEON / CPP kernels:</p>
<div class="fragment"><div class="line"><span class="comment">//Create a kernel object:</span></div><div class="line">MyKernel kernel;</div><div class="line"><span class="comment">// Initialize the kernel with the input/output and options you want to use:</span></div><div class="line">kernel.configure( input, output, option0, option1);</div><div class="line"><span class="comment">// Retrieve the execution window of the kernel:</span></div><div class="line"><span class="keyword">const</span> Window&amp; max_window = kernel.window();</div><div class="line"><span class="comment">// Run the whole kernel in the current thread:</span></div><div class="line">kernel.run( max_window ); <span class="comment">// Run the kernel on the full window</span></div></div><!-- fragment --><h3><a class="anchor" id="S4_2_3"></a>
Multi-threading</h3>
<p>The previous section shows how to run a NEON / CPP kernel in the current thread, however if your system has several CPU cores, you will probably want the kernel to use several cores. Here is how this can be done:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> Window &amp;max_window     = kernel-&gt;window();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>     num_iterations = max_window.num_iterations(split_dimension);</div><div class="line">    <span class="keywordtype">int</span>           num_threads    = std::min(num_iterations, _num_threads);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(!kernel-&gt;is_parallelisable() || 1 == num_threads)</div><div class="line">    {</div><div class="line">        kernel-&gt;run(max_window);</div><div class="line">    }</div><div class="line"><span class="preprocessor">#ifndef NO_MULTI_THREADING</span></div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t = 0; t &lt; num_threads; ++t)</div><div class="line">        {</div><div class="line">            Window win = max_window.split_window(split_dimension, t, num_threads);</div><div class="line">            win.set_thread_id(t);</div><div class="line">            win.set_num_threads(num_threads);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span>(t != num_threads - 1)</div><div class="line">            {</div><div class="line">                _threads[t].start(kernel, win);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                kernel-&gt;run(win);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t = 1; t &lt; num_threads; ++t)</div><div class="line">            {</div><div class="line">                _threads[t - 1].wait();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::system_error &amp;e)</div><div class="line">        {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Caught system_error with code &quot;</span> &lt;&lt; e.code() &lt;&lt; <span class="stringliteral">&quot; meaning &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* NO_MULTI_THREADING */</span><span class="preprocessor"></span></div></div><!-- fragment --><p> This is the very basic implementation used in the NEON runtime library by all the NEON functions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classarm__compute_1_1_c_p_p_scheduler.xhtml" title="Pool of threads to automatically split a kernel&#39;s execution among several threads. ">CPPScheduler</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some kernels like for example <a class="el" href="classarm__compute_1_1_n_e_histogram_kernel.xhtml">NEHistogramKernel</a> need some local temporary buffer to perform their calculations. In order to avoid memory corruption between threads, the local buffer must be of size: <code>memory_needed_per_thread * num_threads</code> and each subwindow must be initialised by calling <a class="el" href="classarm__compute_1_1_window.xhtml#a50ee380d076dd9ce06a35a76903f8b7b">Window::set_thread_id()</a> with a unique thread_id between 0 and num_threads.</dd></dl>
<h3><a class="anchor" id="S4_2_4"></a>
Functions</h3>
<p>Functions will automatically allocate the temporary buffers mentioned above, and will automatically multi-thread kernels' executions using the very basic scheduler described in the previous section.</p>
<p>Simple functions are made of a single kernel (e.g <a class="el" href="classarm__compute_1_1_n_e_convolution3x3.xhtml">NEConvolution3x3</a>), while more complex ones will be made of a several kernels pipelined together (e.g <a class="el" href="classarm__compute_1_1_n_e_gaussian_pyramid.xhtml">NEGaussianPyramid</a>, <a class="el" href="classarm__compute_1_1_n_e_harris_corners.xhtml">NEHarrisCorners</a>), check their documentation to find out which kernels are used by each function.</p>
<div class="fragment"><div class="line"><span class="comment">//Create a function object:</span></div><div class="line">MyFunction <span class="keyword">function</span>;</div><div class="line"><span class="comment">// Initialize the function with the input/output and options you want to use:</span></div><div class="line"><span class="keyword">function</span>.configure( input, output, option0, option1);</div><div class="line"><span class="comment">// Execute the function:</span></div><div class="line"><span class="keyword">function</span>.run();</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>ARM Compute libraries require Mali OpenCL DDK r8p0 or above(OpenCL kernels are compiled using the -cl-arm-non-uniform-work-group-size flag)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All OpenCL functions and objects in the runtime library use the command queue associated with <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a> for all operations, a real implementation would be expected to use different queues for mapping operations and kernels in order to reach a better GPU utilisation.</dd></dl>
<h3><a class="anchor" id="S4_4_1_cl_scheduler"></a>
OpenCL Scheduler and kernel library</h3>
<p>The ARM Compute runtime uses a single command queue and context for all the operations.</p>
<p>The user can get / set this context and command queue through the <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a>'s interface.</p>
<dl class="section attention"><dt>Attention</dt><dd>Make sure the application is using the same context as the library as in OpenCL it is forbidden to share objects across contexts. This is done by calling <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml#adbadebed3b89425740901b16b9d5d947">CLScheduler::init()</a> or <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml#a19bb5002a62b62e050e89c975f7b9fdf">CLScheduler::default_init()</a> at the beginning of your application.</dd></dl>
<p>All the OpenCL kernels used by the library are built and stored in the <a class="el" href="classarm__compute_1_1_c_l_kernel_library.xhtml">CLKernelLibrary</a>. If the library is compiled with embed_kernels=0 the application can set the path to the OpenCL kernels by calling <a class="el" href="classarm__compute_1_1_c_l_kernel_library.xhtml#af353532ea782387df6bcb6d01894f4ae">CLKernelLibrary::init()</a>, by default the path is set to "./cl_kernels"</p>
<h3><a class="anchor" id="S4_4_2_events_sync"></a>
OpenCL events and synchronisation</h3>
<p>In order to block until all the jobs in the <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml" title="Provides global access to a CL context and command queue. ">CLScheduler</a>'s command queue are done executing the user can call <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml#ad55f80ed3cd8b6c4f247763b747016af">CLScheduler::sync()</a> or create a sync event using <a class="el" href="classarm__compute_1_1_c_l_scheduler.xhtml#a6096d26e8e29e1a7f01b0f083fb7e33f">CLScheduler::enqueue_sync_event()</a></p>
<p>For example: </p><div class="fragment"><div class="line">    PPMLoader     ppm;</div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#aae712f442eae2d56d17529ca6cb9cb77">CLImage</a>       src, tmp_scale_median, tmp_median_gauss, dst;</div><div class="line">    constexpr <span class="keywordtype">int</span> scale_factor = 2;</div><div class="line"></div><div class="line">    <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a19bb5002a62b62e050e89c975f7b9fdf">default_init</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 2)</div><div class="line">    {</div><div class="line">        <span class="comment">// Print help</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: ./build/cl_events [input_image.ppm]\n\n&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;No input_image provided, creating a dummy 640x480 image\n&quot;</span>;</div><div class="line">        <span class="comment">// Create an empty grayscale 640x480 image</span></div><div class="line">        src.allocator()-&gt;init(TensorInfo(640, 480, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        ppm.open(argv[1]);</div><div class="line">        ppm.init_image(src, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Declare and configure the functions to create the following pipeline: scale -&gt; median -&gt; gauss</span></div><div class="line">    CLScale       scale;</div><div class="line">    CLMedian3x3   median;</div><div class="line">    CLGaussian5x5 gauss;</div><div class="line"></div><div class="line">    TensorInfo dst_info(src.info()-&gt;dimension(0) / scale_factor, src.info()-&gt;dimension(1) / scale_factor, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Configure the temporary and destination images</span></div><div class="line">    dst.allocator()-&gt;init(dst_info);</div><div class="line">    tmp_scale_median.allocator()-&gt;init(dst_info);</div><div class="line">    tmp_median_gauss.allocator()-&gt;init(dst_info);</div><div class="line"></div><div class="line">    <span class="comment">//Configure the functions:</span></div><div class="line">    scale.configure(&amp;src, &amp;tmp_scale_median, <a class="code" href="namespacearm__compute.xhtml#a966a9c417ce5e94dca08d9b5e745c0c9a7f5ccbc3d30c2cd3fd04d567946cbde2">InterpolationPolicy::NEAREST_NEIGHBOR</a>, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line">    median.configure(&amp;tmp_scale_median, &amp;tmp_median_gauss, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line">    gauss.configure(&amp;tmp_median_gauss, &amp;dst, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate all the images</span></div><div class="line">    src.allocator()-&gt;allocate();</div><div class="line">    dst.allocator()-&gt;allocate();</div><div class="line">    tmp_scale_median.allocator()-&gt;allocate();</div><div class="line">    tmp_median_gauss.allocator()-&gt;allocate();</div><div class="line">    <span class="comment">// Fill the input image with the content of the PPM image if a filename was provided:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        ppm.fill_image(src);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Enqueue and flush the scale OpenCL kernel:</span></div><div class="line">    scale.run();</div><div class="line">    <span class="comment">// Create a synchronisation event between scale and median:</span></div><div class="line">    cl::Event scale_event = <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a6096d26e8e29e1a7f01b0f083fb7e33f">enqueue_sync_event</a>();</div><div class="line">    <span class="comment">// Enqueue and flush the median OpenCL kernel:</span></div><div class="line">    median.run();</div><div class="line">    <span class="comment">// Enqueue and flush the Gaussian OpenCL kernel:</span></div><div class="line">    gauss.run();</div><div class="line"></div><div class="line">    <span class="comment">//Make sure all the OpenCL jobs are done executing:</span></div><div class="line">    scale_event.wait();        <span class="comment">// Block until Scale is done executing (Median3x3 and Gaussian5x5 might still be running)</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#ad55f80ed3cd8b6c4f247763b747016af">sync</a>(); <span class="comment">// Block until Gaussian5x5 is done executing</span></div><div class="line"></div><div class="line">    <span class="comment">// Save the result to file:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> std::string output_filename = std::string(argv[1]) + <span class="stringliteral">&quot;_out.ppm&quot;</span>;</div><div class="line">        <a class="code" href="namespacetest__helpers.xhtml#a5036a1b77bd7223a68954b5078c6545a">save_to_ppm</a>(dst, output_filename); <span class="comment">// save_to_ppm maps and unmaps the image to store as PPM</span></div><div class="line">    }</div></div><!-- fragment --> <h3><a class="anchor" id="S4_4_2_cl_neon"></a>
OpenCL / NEON interoperability</h3>
<p>You can mix OpenCL and NEON kernels and or functions, however it is the user's responsibility to handle the mapping unmapping of the OpenCL objects, for example:</p>
<div class="fragment"><div class="line">    PPMLoader ppm;</div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#aae712f442eae2d56d17529ca6cb9cb77">CLImage</a>   src, scale_median, median_gauss, dst;</div><div class="line"></div><div class="line">    <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a19bb5002a62b62e050e89c975f7b9fdf">default_init</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 2)</div><div class="line">    {</div><div class="line">        <span class="comment">// Print help</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: ./build/cl_convolution [input_image.ppm]\n\n&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;No input_image provided, creating a dummy 640x480 image\n&quot;</span>;</div><div class="line">        <span class="comment">// Create an empty grayscale 640x480 image</span></div><div class="line">        src.allocator()-&gt;init(TensorInfo(640, 480, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        ppm.open(argv[1]);</div><div class="line">        ppm.init_image(src, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    TensorInfo scale_median_info(TensorInfo(src.info()-&gt;dimension(0) / 2, src.info()-&gt;dimension(1) / 2, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>));</div><div class="line"></div><div class="line">    <span class="comment">// Configure the temporary and destination images</span></div><div class="line">    scale_median.allocator()-&gt;init(scale_median_info);</div><div class="line">    median_gauss.allocator()-&gt;init(scale_median_info);</div><div class="line">    dst.allocator()-&gt;init(scale_median_info);</div><div class="line"></div><div class="line">    <span class="comment">// Declare and configure the functions to create the following pipeline: scale -&gt; median -&gt; gauss</span></div><div class="line">    CLScale       scale;</div><div class="line">    NEMedian3x3   median;</div><div class="line">    CLGaussian5x5 gauss;</div><div class="line"></div><div class="line">    scale.configure(&amp;src, &amp;scale_median, <a class="code" href="namespacearm__compute.xhtml#a966a9c417ce5e94dca08d9b5e745c0c9a7f5ccbc3d30c2cd3fd04d567946cbde2">InterpolationPolicy::NEAREST_NEIGHBOR</a>, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line">    median.configure(&amp;scale_median, &amp;median_gauss, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line">    gauss.configure(&amp;median_gauss, &amp;dst, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate all the images</span></div><div class="line">    src.allocator()-&gt;allocate();</div><div class="line">    scale_median.allocator()-&gt;allocate();</div><div class="line">    median_gauss.allocator()-&gt;allocate();</div><div class="line">    dst.allocator()-&gt;allocate();</div><div class="line"></div><div class="line">    <span class="comment">// Fill the input image with the content of the PPM image if a filename was provided:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        ppm.fill_image(src);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Enqueue and flush the OpenCL kernel:</span></div><div class="line">    scale.run();</div><div class="line"></div><div class="line">    <span class="comment">// Do a blocking map of the input and output buffers of the NEON function:</span></div><div class="line">    scale_median.map();</div><div class="line">    median_gauss.map();</div><div class="line"></div><div class="line">    <span class="comment">// Run the NEON function:</span></div><div class="line">    median.run();</div><div class="line"></div><div class="line">    <span class="comment">// Unmap the output buffer before it&#39;s used again by OpenCL:</span></div><div class="line">    scale_median.unmap();</div><div class="line">    median_gauss.unmap();</div><div class="line"></div><div class="line">    <span class="comment">// Run the final OpenCL function:</span></div><div class="line">    gauss.run();</div><div class="line"></div><div class="line">    <span class="comment">// Make sure all the OpenCL jobs are done executing:</span></div><div class="line">    <a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#a60f9a6836b628a7171914c4afe43b4a7">CLScheduler::get</a>().<a class="code" href="classarm__compute_1_1_c_l_scheduler.xhtml#ad55f80ed3cd8b6c4f247763b747016af">sync</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Save the result to file:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> std::string output_filename = std::string(argv[1]) + <span class="stringliteral">&quot;_out.ppm&quot;</span>;</div><div class="line">        <a class="code" href="namespacetest__helpers.xhtml#a5036a1b77bd7223a68954b5078c6545a">save_to_ppm</a>(dst, output_filename); <span class="comment">// save_to_ppm maps and unmaps the image to store as PPM</span></div><div class="line">    }</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="neoncl__scale__median__gaussian_8cpp.xhtml#a4003cb8b626a6604e2f51b8e17f8bb3d" title="Example demonstrating how to use both CL and NEON functions in the same pipeline. ...">main_neoncl_scale_median_gaussian</a></dd></dl>
<h2><a class="anchor" id="S4_5_algorithms"></a>
Algorithms</h2>
<p>All algorithms in this library have been implemented following the <a href="https://www.khronos.org/registry/vx/specs/1.1/html/">OpenVX 1.1 specifications</a> Please refer to the Khronos documentation for more information.</p>
<h2><a class="anchor" id="S4_6_images_tensors"></a>
Images, padding, border modes and tensors</h2>
<p>Most kernels and functions in the library process images, however, in order to be future proof most of the kernels actually accept tensors, see below for more information about they are related.</p>
<dl class="section attention"><dt>Attention</dt><dd>Each memory object can be written by only one kernel, however it can be read by several kernels. Writing to the same object from several kernels will result in undefined behaviour. The kernel writing to an object must be configured before the kernel(s) reading from it.</dd></dl>
<h3><a class="anchor" id="S4_6_1_padding_and_border"></a>
Padding and border modes</h3>
<p>Several algorithms rely on neighbour pixels to calculate the value of a given pixel: this means the algorithm will not be able to process the borders of the image unless you give it more information about what you want to happen for border pixels, this is the <a class="el" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327">BorderMode</a>.</p>
<p>You have 3 types of <a class="el" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327">BorderMode</a> :</p>
<ul>
<li><a class="el" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a0db45d2a4141101bdfe48e3314cfbca3">BorderMode::UNDEFINED</a> : if you are missing pixel values then don't calculate the value. As a result all the pixels which are on the border will have a value which is undefined.</li>
<li><a class="el" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a4ef59320fbe90fe47d40f1f71e4c5daa">BorderMode::REPLICATE</a> : if you are missing pixel values then assume the missing pixels have the same value as the closest valid pixel.</li>
<li><a class="el" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a8d6b5cada83510220f59e00ce86d4d92">BorderMode::CONSTANT</a> : if you are missing pixel values then assume the missing pixels all have the same constant value (The user can choose what this value should be).</li>
</ul>
<p>Moreover both OpenCL and NEON use vector loads and stores instructions to access the data in buffers, so in order to avoid having special cases to handle for the borders all the images and tensors used in this library must be padded.</p>
<h4><a class="anchor" id="padding"></a>
Padding</h4>
<p>There are different ways padding can be calculated:</p>
<ul>
<li>Accurate padding:</li>
</ul>
<div class="fragment"><div class="line">    PPMLoader ppm;</div><div class="line">    <a class="code" href="struct_image.xhtml">Image</a>     src, tmp, dst;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(argc &lt; 2)</div><div class="line">    {</div><div class="line">        <span class="comment">// Print help</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: ./build/neon_convolution [input_image.ppm]\n\n&quot;</span>;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;No input_image provided, creating a dummy 640x480 image\n&quot;</span>;</div><div class="line">        <span class="comment">// Initialize just the dimensions and format of your buffers:</span></div><div class="line">        src.allocator()-&gt;init(TensorInfo(640, 480, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        ppm.open(argv[1]);</div><div class="line">        <span class="comment">// Initialize just the dimensions and format of your buffers:</span></div><div class="line">        ppm.init_image(src, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Initialize just the dimensions and format of the temporary and destination images:</span></div><div class="line">    tmp.allocator()-&gt;init(*src.info());</div><div class="line">    dst.allocator()-&gt;init(*src.info());</div><div class="line"></div><div class="line">    NEConvolution3x3 conv3x3;</div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#adbc7771d367ba8f51da1450d3602e5c0">NEConvolution5x5</a> conv5x5;</div><div class="line"></div><div class="line">    <span class="comment">// Apply a Gaussian 3x3 filter to the source image followed by a Gaussian 5x5:</span></div><div class="line">    <span class="comment">// The function will automatically update the padding information inside input and output to match its requirements</span></div><div class="line">    conv3x3.configure(&amp;src, &amp;tmp, <a class="code" href="cl__convolution_8cpp.xhtml#a741ba5321da40184f8653e0a50ace070">gaussian3x3</a>, 0 <span class="comment">/* Let arm_compute calculate the scale */</span>, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a0db45d2a4141101bdfe48e3314cfbca3">BorderMode::UNDEFINED</a>);</div><div class="line">    conv5x5.configure(&amp;tmp, &amp;dst, <a class="code" href="cl__convolution_8cpp.xhtml#a565013cf7e49a591bacd548571951f94">gaussian5x5</a>, 0 <span class="comment">/* Let arm_compute calculate the scale */</span>, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a0db45d2a4141101bdfe48e3314cfbca3">BorderMode::UNDEFINED</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Now that the padding requirements are known we can allocate the images:</span></div><div class="line">    src.allocator()-&gt;allocate();</div><div class="line">    tmp.allocator()-&gt;allocate();</div><div class="line">    dst.allocator()-&gt;allocate();</div><div class="line"></div><div class="line">    <span class="comment">// Fill the input image with the content of the PPM image if a filename was provided:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        ppm.fill_image(src);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">//Execute the functions:</span></div><div class="line">    conv3x3.run();</div><div class="line">    conv5x5.run();</div><div class="line"></div><div class="line">    <span class="comment">// Save the result to file:</span></div><div class="line">    <span class="keywordflow">if</span>(ppm.is_open())</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> std::string output_filename = std::string(argv[1]) + <span class="stringliteral">&quot;_out.ppm&quot;</span>;</div><div class="line">        <a class="code" href="namespacetest__helpers.xhtml#a5036a1b77bd7223a68954b5078c6545a">save_to_ppm</a>(dst, output_filename);</div><div class="line">    }</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>It's important to call allocate <b>after</b> the function is configured: if the image / tensor is already allocated then the function will shrink its execution window instead of increasing the padding. (See below for more details).</dd></dl>
<ul>
<li>Manual padding / no padding / auto padding: You can allocate your images / tensors up front (before configuring your functions), in that case the function will use whatever padding is available and will shrink its execution window if there isn't enough padding available (Which will translates into a smaller valid region for the output. See also <a class="el" href="index.xhtml#valid_region">Valid regions</a>). If you don't want to manually set the padding but still want to allocate your objects upfront then you can use auto_padding.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="struct_image.xhtml">Image</a>     src, dst;</div><div class="line"></div><div class="line"><span class="comment">// Use auto padding for the input:</span></div><div class="line">src.info()-&gt;init_auto_padding(TensorShape(640u,480u), <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>);</div><div class="line"></div><div class="line"><span class="comment">// Use manual padding for the destination image</span></div><div class="line">dst.info()-&gt;init(src.info()-&gt;tensor_shape(), <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a6669348b484e3008dca2bfa8e85e40b5">Format::U8</a>, strides_in_bytes, offset_first_element_in_bytes, total_size_in_bytes);</div><div class="line"></div><div class="line"><span class="comment">// Allocate all the images</span></div><div class="line">src.allocator()-&gt;allocate();</div><div class="line">dst.allocator()-&gt;allocate();</div><div class="line"><span class="comment">// Fill the input image with the content of the PPM image if a filename was provided:</span></div><div class="line">fill_image(src);</div><div class="line"></div><div class="line">NEGaussian3x3 gauss;</div><div class="line"></div><div class="line"><span class="comment">// Apply a Gaussian 3x3 filter to the source image (Note: if the padding provided is not enough then the execution window and valid region of the output will be shrunk)</span></div><div class="line">gauss.configure(&amp;src, &amp;dst, <a class="code" href="namespacearm__compute.xhtml#a15a05537a472ee742404821851529327a0db45d2a4141101bdfe48e3314cfbca3">BorderMode::UNDEFINED</a>);</div><div class="line"></div><div class="line"><span class="comment">//Execute the functions:</span></div><div class="line">gauss.run();</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Some kernels need up to 3 neighbour values to calculate the value of a given pixel, therefore to be safe we use a 4 pixels padding all around the image and some kernels read and write up to 32 pixels at the time, therefore we add an extra 32 pixels of padding at the end of each row to be safe. As a result auto padded buffers waste a lot of memory and are less cache friendly. It is therefore recommended to use accurate padding or manual padding wherever possible.</dd></dl>
<h4><a class="anchor" id="valid_region"></a>
Valid regions</h4>
<p>Some kernels (like edge detectors for example) need to read values of neighbouring pixels to calculate the value of a given pixel, it is therefore not possible to calculate the values of the pixels on the edges.</p>
<p>Another case is: if a kernel processes 8 pixels per iteration then if the image's dimensions is not a multiple of 8 and not enough padding is available then the kernel will not be able to process the pixels near the right edge as a result these pixels will be left undefined.</p>
<p>In order to know which pixels have been calculated, each kernel sets a valid region for each output image or tensor. See also <a class="el" href="classarm__compute_1_1_tensor_info.xhtml#ac437ef0718add962a4059fb3b3084c34">TensorInfo::valid_region()</a>, <a class="el" href="structarm__compute_1_1_valid_region.xhtml">ValidRegion</a></p>
<h3><a class="anchor" id="S4_6_2_tensors"></a>
Tensors</h3>
<p>Tensors are multi-dimensional arrays made of up to <a class="el" href="classarm__compute_1_1_dimensions.xhtml#a1b67d5b720119d50faa286c774579ecc">Coordinates::num_max_dimensions</a> dimensions.</p>
<p>A simple vector of numbers can be represented as a 1D tensor, an image is actually just a 2D tensor, a 3D tensor can be seen as an array of images, a 4D tensor as a 2D array of images, etc.</p>
<dl class="section note"><dt>Note</dt><dd>Most algorithms process images (i.e a 2D slice of the tensor), therefore only padding along the X and Y axes is required (2D slices can be stored contiguously in memory).</dd></dl>
<h3><a class="anchor" id="S4_6_3_description_conventions"></a>
Images and Tensors description conventions</h3>
<p><a class="el" href="struct_image.xhtml" title="Structure to hold Image information. ">Image</a> objects are defined by a <a class="el" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58">Format</a> and dimensions expressed as [width, height, batch]</p>
<p>Tensors are defined by a <a class="el" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> plus a number of channels (Always expected to be 1 for now) and their dimensions are expressed as [width, height, feature_maps, batch].</p>
<p>In other words, the lower three dimensions of a tensor specify a single input in [width, height, feature_maps], while any other specified dimension represents a batch in the appropriate dimension space. For example, a tensor with dimensions [128, 128, 64, 16] represents a 1D batch space with 16 batches of 128 elements in width and height and 64 feature maps each. Each kernel specifies the expected layout of each of its tensors in its documentation.</p>
<dl class="section note"><dt>Note</dt><dd>Unless specified otherwise in the kernel's or function's documentation all tensors and images parameters passed must have identical dimensions.</dd>
<dd>
Unless specified otherwise in the kernel's or function's documentation the number of channels for tensors is expected to be 1 (For images, the number of channels is inferred from the <a class="el" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58">Format</a>).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Regardless of the <a class="el" href="namespacearm__compute.xhtml#ad8ed01ff3ff33333d8e19db4d2818bb6">DataType</a> used by a tensor the <a class="el" href="classarm__compute_1_1_i_tensor.xhtml#ab988210662dbd3bf32fd563c7dd1bdbf">ITensor::buffer()</a> method will always return a uint8_t pointer, and all the metadata in <a class="el" href="classarm__compute_1_1_tensor_info.xhtml">TensorInfo</a> will be expressed in bytes. It is the user's responsibility to cast the pointer to the correct type.</dd></dl>
<p>For example, to read the element located at the coordinates (x,y) of a float tensor:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> value = *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(input.buffer() + input.info()-&gt;offset_element_in_bytes(Coordinates(x,y)));</div></div><!-- fragment --><h3><a class="anchor" id="S4_6_4_working_with_objects"></a>
Working with Images and Tensors using iterators</h3>
<p>The library provides some iterators to access objects' data. Iterators are created by associating a data object (An image or a tensor for example) with an iteration window.</p>
<p>Iteration windows are defined by an array of dimension, each of which is made of a start, end and step.</p>
<p>The <a class="el" href="namespacearm__compute.xhtml#a78fd1c0056e9add7ab01b8e118c0038d">execute_window_loop</a> function takes an execution window, a lambda function and one or more iterators. It will iterate through every element of the execution window and for each element it will update the iterators accordingly and call the lambda function.</p>
<p>Here is a couple of examples of how to use the iterators to fill / read tensors:</p>
<div class="fragment"><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width  = 4;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height = 3;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> batch  = 2;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> *src_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[width * height * batch];</div><div class="line">    <span class="keyword">auto</span> *dst_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[width * height * batch];</div><div class="line"></div><div class="line">    <span class="comment">// Fill src_data with dummy values:</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = 0; b &lt; batch; b++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h = 0; h &lt; height; h++)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> w = 0; w &lt; width; w++)</div><div class="line">            {</div><div class="line">                src_data[b * (width * height) + h * width + w] = static_cast&lt;float&gt;(100 * b + 10 * h + w);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    Tensor         input, output;</div><div class="line">    NESoftmaxLayer softmax;</div><div class="line"></div><div class="line">    <span class="comment">// Initialize the tensors dimensions and type:</span></div><div class="line">    <span class="keyword">const</span> TensorShape shape(width, height, batch);</div><div class="line">    input.allocator()-&gt;init(TensorInfo(shape, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line">    output.allocator()-&gt;init(TensorInfo(shape, 1, <a class="code" href="namespacearm__compute.xhtml#ab4e88c89b3b7ea1735996cc4def22d58a44ad4ef5a76e6aa6fb3e3fa079a54fda">DataType::F32</a>));</div><div class="line"></div><div class="line">    <span class="comment">// Configure softmax:</span></div><div class="line">    softmax.configure(&amp;input, &amp;output);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate the input / output tensors:</span></div><div class="line">    input.allocator()-&gt;allocate();</div><div class="line">    output.allocator()-&gt;allocate();</div><div class="line"></div><div class="line">    <span class="comment">// Fill the input tensor:</span></div><div class="line">    <span class="comment">// Simplest way: create an iterator to iterate through each element of the input tensor:</span></div><div class="line">    Window input_window;</div><div class="line">    input_window.use_tensor_dimensions(input.info());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Dimensions of the input&#39;s iterator:\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; X = [start=&quot;</span> &lt;&lt; input_window.x().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; input_window.x().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; input_window.x().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Y = [start=&quot;</span> &lt;&lt; input_window.y().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; input_window.y().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; input_window.y().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Z = [start=&quot;</span> &lt;&lt; input_window.z().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; input_window.z().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; input_window.z().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Create an iterator:</span></div><div class="line">    Iterator input_it(&amp;input, input_window);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate through the elements of src_data and copy them one by one to the input tensor:</span></div><div class="line">    <span class="comment">// This is equivalent to:</span></div><div class="line">    <span class="comment">// for( unsigned int z = 0; z &lt; batch; ++z)</span></div><div class="line">    <span class="comment">// {</span></div><div class="line">    <span class="comment">//   for( unsigned int y = 0; y &lt; height; ++y)</span></div><div class="line">    <span class="comment">//   {</span></div><div class="line">    <span class="comment">//     for( unsigned int x = 0; x &lt; width; ++x)</span></div><div class="line">    <span class="comment">//     {</span></div><div class="line">    <span class="comment">//       *reinterpret_cast&lt;float*&gt;( input.buffer() + input.info()-&gt;offset_element_in_bytes(Coordinates(x,y,z))) = src_data[ z * (width*height) + y * width + x];</span></div><div class="line">    <span class="comment">//     }</span></div><div class="line">    <span class="comment">//   }</span></div><div class="line">    <span class="comment">// }</span></div><div class="line">    <span class="comment">// Except it works for an arbitrary number of dimensions</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a78fd1c0056e9add7ab01b8e118c0038d">execute_window_loop</a>(input_window, [&amp;](<span class="keyword">const</span> Coordinates &amp; <span class="keywordtype">id</span>)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Setting item [&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.x() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.y() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.z() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">        *<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(input_it.ptr()) = src_data[<span class="keywordtype">id</span>.z() * (width * height) + <span class="keywordtype">id</span>.y() * width + <span class="keywordtype">id</span>.x()];</div><div class="line">    },</div><div class="line">    input_it);</div><div class="line"></div><div class="line">    <span class="comment">// Run NEON softmax:</span></div><div class="line">    softmax.run();</div><div class="line"></div><div class="line">    <span class="comment">// More efficient way: create an iterator to iterate through each row (instead of each element) of the output tensor:</span></div><div class="line">    Window output_window;</div><div class="line">    output_window.use_tensor_dimensions(output.info(), <span class="comment">/* first_dimension =*/</span><a class="code" href="classarm__compute_1_1_window.xhtml#ad2d402364fa822b0b7775081291eeca9">Window::DimY</a>); <span class="comment">// Iterate through the rows (not each element)</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Dimensions of the output&#39;s iterator:\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; X = [start=&quot;</span> &lt;&lt; output_window.x().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; output_window.x().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; output_window.x().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Y = [start=&quot;</span> &lt;&lt; output_window.y().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; output_window.y().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; output_window.y().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; Z = [start=&quot;</span> &lt;&lt; output_window.z().start() &lt;&lt; <span class="stringliteral">&quot;, end=&quot;</span> &lt;&lt; output_window.z().end() &lt;&lt; <span class="stringliteral">&quot;, step=&quot;</span> &lt;&lt; output_window.z().step() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Create an iterator:</span></div><div class="line">    Iterator output_it(&amp;output, output_window);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate through the rows of the output tensor and copy them to dst_data:</span></div><div class="line">    <span class="comment">// This is equivalent to:</span></div><div class="line">    <span class="comment">// for( unsigned int z = 0; z &lt; batch; ++z)</span></div><div class="line">    <span class="comment">// {</span></div><div class="line">    <span class="comment">//   for( unsigned int y = 0; y &lt; height; ++y)</span></div><div class="line">    <span class="comment">//   {</span></div><div class="line">    <span class="comment">//     memcpy( dst_data + z * (width*height) + y * width, input.buffer() + input.info()-&gt;offset_element_in_bytes(Coordinates(0,y,z)), width * sizeof(float));</span></div><div class="line">    <span class="comment">//   }</span></div><div class="line">    <span class="comment">// }</span></div><div class="line">    <span class="comment">// Except it works for an arbitrary number of dimensions</span></div><div class="line">    <a class="code" href="namespacearm__compute.xhtml#a78fd1c0056e9add7ab01b8e118c0038d">execute_window_loop</a>(output_window, [&amp;](<span class="keyword">const</span> Coordinates &amp; <span class="keywordtype">id</span>)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Copying one row starting from [&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.x() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.y() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <span class="keywordtype">id</span>.z() &lt;&lt; <span class="stringliteral">&quot;]\n&quot;</span>;</div><div class="line">        <span class="comment">// Copy one whole row:</span></div><div class="line">        memcpy(dst_data + <span class="keywordtype">id</span>.z() * (width * height) + <span class="keywordtype">id</span>.y() * width, output_it.ptr(), width * <span class="keyword">sizeof</span>(float));</div><div class="line">    },</div><div class="line">    output_it);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] src_data;</div><div class="line">    <span class="keyword">delete</span>[] dst_data;</div></div><!-- fragment --></div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 3 2017 17:20:05 for ARM Compute Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
